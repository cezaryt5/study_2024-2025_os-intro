---
## Author
author:
  name: Mohamed Musa
  student_number: "1032248286"
  group: "НКАбд-05"
  year: "2 год"
  email: "1032248286@pfur.ru"
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 19

## Title
title: "Лабораторная работа №12"
subtitle: "Программирование в командном процессоре ОС UNIX. Расширенное программирование"
license: "CC BY"
---

# Цель работы

Изучить основы программирования в оболочке ОС UNIX. Научиться писать более сложные командные файлы с использованием логических управляющих конструкций и циклов.

# Задание

1. Написать скрипт для создания резервной копии самого себя с архивацией
2. Написать скрипт для обработки произвольного числа аргументов командной строки
3. Написать командный файл — аналог команды ls
4. Написать скрипт для подсчета файлов с заданным расширением в директории

# Теоретическое введение

## Командная оболочка bash

**Bash (Bourne Again Shell)** — командная оболочка UNIX, интерпретатор командного языка.

**Основные возможности:**

- Выполнение команд и программ
- Переменные окружения и пользовательские переменные
- Условные операторы (if, case)
- Циклы (for, while, until)
- Функции
- Обработка аргументов командной строки
- Перенаправление ввода-вывода

## Специальные переменные

**Аргументы командной строки:**

- `$0` — имя скрипта
- `$1, $2, ..., $9` — первые 9 аргументов
- `${10}, ${11}, ...` — аргументы начиная с 10-го
- `$#` — количество аргументов
- `$@` — все аргументы как отдельные слова
- `$*` — все аргументы как одна строка

**Другие переменные:**

- `$?` — код возврата последней команды
- `$$` — PID текущего процесса
- `$!` — PID последнего фонового процесса
- `$HOME` — домашний каталог пользователя
- `$USER` — имя пользователя

## Условные операторы

**Проверка файлов:**

- `-e file` — файл существует
- `-f file` — обычный файл
- `-d file` — директория
- `-r file` — файл доступен для чтения
- `-w file` — файл доступен для записи
- `-x file` — файл исполняемый

**Сравнение чисел:**

- `-eq` — равно
- `-ne` — не равно
- `-lt` — меньше
- `-le` — меньше или равно
- `-gt` — больше
- `-ge` — больше или равно

## Архивация файлов

**Команда zip:**

```bash
zip archive.zip file1 file2    # создать архив
zip -j archive.zip /path/file  # без сохранения пути
unzip archive.zip              # распаковать
```

**Команда tar:**

```bash
tar -czf archive.tar.gz files  # создать gzip архив
tar -xzf archive.tar.gz        # распаковать
```

# Выполнение лабораторной работы

## Задание 1: Скрипт резервного копирования

Создан скрипт `backup_script.sh`, который создает резервную копию самого себя в директории `~/backup` с использованием архиватора zip.

**Содержимое скрипта:**

```bash
#!/bin/bash
# Script to backup itself to a backup directory in home folder

# Create backup directory in home if it doesn't exist
BACKUP_DIR="$HOME/backup"
mkdir -p "$BACKUP_DIR"

# Get the script's filename
SCRIPT_NAME=$(basename "$0")

# Create a timestamp for the backup
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")

# Create backup filename with timestamp
BACKUP_FILE="$BACKUP_DIR/${SCRIPT_NAME}_${TIMESTAMP}.zip"

# Use zip to archive the script
zip -j "$BACKUP_FILE" "$0"

echo "Backup created: $BACKUP_FILE"
```

**Описание работы скрипта:**

1. Создается директория `~/backup` если её не существует (команда `mkdir -p`)
2. Получается имя текущего скрипта с помощью `basename "$0"`
3. Создается временная метка в формате `YYYYMMDD_HHMMSS`
4. Формируется полное имя файла архива с временной меткой
5. Скрипт архивируется командой `zip -j` (опция `-j` исключает путь к файлу)
6. Выводится сообщение о создании резервной копии

Содержимое скрипта показано на рисунке @fig-content1.

![Содержимое скрипта backup_script.sh](image/content1.png){#fig-content1 width=80%}

**Пример выполнения скрипта:**

```bash
$ ./backup_script.sh
adding: backup_script.sh (deflated 42%)
Backup created: /home/ceazer/backup/backup_script.sh_20251013_225107.zip
```

Скрипт успешно создает архив с временной меткой в директории `~/backup`. Архив содержит исходный код скрипта и может быть восстановлен командой `unzip`.

## Задание 2: Обработка произвольного числа аргументов

Создан скрипт `argument_handler.sh`, который обрабатывает любое количество аргументов командной строки.

**Содержимое скрипта:**

```bash
#!/bin/bash
# Script to handle arbitrary number of arguments

echo "Number of arguments: $#"

# Using a for loop to iterate through all arguments
counter=1
for arg in "$@"; do
    echo "Argument $counter: $arg"
    ((counter++))
done

# Alternative method using while loop
echo ""
echo "Using while loop method:"
index=1
while [ $index -le $# ]; do
    eval "current_arg=\${$index}"
    echo "Argument $index: $current_arg"
    ((index++))
done
```

**Описание работы скрипта:**

1. Выводится общее количество аргументов с помощью `$#`
2. **Первый метод** — цикл `for` с использованием `"$@"`:
   - Переменная `"$@"` содержит все аргументы как отдельные элементы
   - Цикл перебирает каждый аргумент
   - Счетчик увеличивается с помощью `((counter++))`
3. **Второй метод** — цикл `while` с индексацией:
   - Используется команда `eval` для доступа к аргументам по номеру
   - Конструкция `\${$index}` позволяет получить значение переменной `$1`, `$2` и т.д.
   - Цикл продолжается пока индекс не превысит количество аргументов

Содержимое скрипта показано на рисунке @fig-content2.

![Содержимое скрипта argument_handler.sh](image/content2.png){#fig-content2 width=80%}

**Пример выполнения с 12 аргументами:**

```bash
$ ./argument_handler.sh arg1 arg2 arg3 "argument with spaces" arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12
Number of arguments: 12
Argument 1: arg1
Argument 2: arg2
Argument 3: arg3
Argument 4: argument with spaces
Argument 5: arg5
Argument 6: arg6
Argument 7: arg7
Argument 8: arg8
Argument 9: arg9
Argument 10: arg10
Argument 11: arg11
Argument 12: arg12

Using while loop method:
Argument 1: arg1
Argument 2: arg2
Argument 3: arg3
Argument 4: argument with spaces
Argument 5: arg5
Argument 6: arg6
Argument 7: arg7
Argument 8: arg8
Argument 9: arg9
Argument 10: arg10
Argument 11: arg11
Argument 12: arg12
```

Скрипт успешно обрабатывает все 12 аргументов, включая аргумент с пробелами, используя оба метода итерации.

## Задание 3: Аналог команды ls

Создан скрипт `ls_like.sh`, который выводит информацию о содержимом директории без использования команд `ls` или `dir`.

**Содержимое скрипта (основная часть):**

```bash
#!/bin/bash
# Script to mimic ls command without using ls or dir

# Default to current directory if no argument provided
DIRECTORY="${1:-.}"

# Check if directory exists
if [ ! -d "$DIRECTORY" ]; then
    echo "Error: $DIRECTORY is not a directory" >&2
    exit 1
fi

# Print directory contents with permissions
for item in "$DIRECTORY"/*; do
    # Remove directory path from item name for display
    basename_item=$(basename "$item")
    
    # Get file permissions, owner, size, and modification time
    if [ -e "$item" ]; then
        permissions=$(stat -c "%A" "$item" 2>/dev/null || stat -f "%Sp" "$item" 2>/dev/null)
        owner=$(stat -c "%U" "$item" 2>/dev/null || stat -f "%Su" "$item" 2>/dev/null)
        size=$(stat -c "%s" "$item" 2>/dev/null || stat -f "%z" "$item" 2>/dev/null)
        mod_time=$(stat -c "%y" "$item" 2>/dev/null || stat -f "%Sm" "$item" 2>/dev/null)
        
        # Show different indicators for different file types
        if [ -d "$item" ]; then
            type_indicator="d"
            name_with_indicator="$basename_item/"
        elif [ -L "$item" ]; then
            type_indicator="l"
            name_with_indicator="$basename_item@ -> $(readlink "$item")"
        elif [ -x "$item" ]; then
            type_indicator="-"
            name_with_indicator="$basename_item*"
        else
            type_indicator="-"
            name_with_indicator="$basename_item"
        fi
        
        printf "%-10s %-10s %8s %s %s\n" "$permissions" "$owner" "$size" "$mod_time" "$name_with_indicator"
    fi
done
```

**Описание работы скрипта:**

1. Устанавливается директория по умолчанию (текущая) если аргумент не передан
2. Проверяется существование директории
3. Для каждого элемента в директории:
   - Извлекается базовое имя файла
   - Получается информация с помощью команды `stat`:
     - Права доступа (`%A`)
     - Владелец (`%U`)
     - Размер (`%s`)
     - Время модификации (`%y`)
   - Определяется тип файла и добавляется индикатор:
     - `/` для директорий
     - `@` для символических ссылок
     - `*` для исполняемых файлов
   - Информация форматируется и выводится
4. Аналогично обрабатываются скрытые файлы (начинающиеся с `.`)

Содержимое скрипта показано на рисунке @fig-program1.

![Содержимое скрипта ls_like.sh](image/program1.png){#fig-program1 width=80%}

Запуск скрипта показан на рисунке @fig-shcontent1.

![Запуск скрипта ls_like.sh](image/shcontent1.png){#fig-shcontent1 width=80%}

**Пример выполнения скрипта:**

```bash
$ ./ls_like.sh .
-rwxr-xr-x ceazer          444 2025-10-13 17:05:28.490409475 +0000 argument_handler.sh*
-rwxr-xr-x ceazer          504 2025-10-13 17:05:10.180840102 +0000 backup_script.sh*
-rwxr-xr-x ceazer          771 2025-10-13 17:06:21.008836802 +0000 file_counter.sh*
-rwxr-xr-x ceazer         2969 2025-10-13 17:06:00.272728724 +0000 ls_like.sh*
drwxr-xr-x ceazer         4096 2025-10-13 22:45:55.295731834 +0000 presentation/
drwxr-xr-x ceazer         4096 2025-10-13 22:46:12.688731396 +0000 report/
```

Скрипт выводит подробную информацию о файлах и директориях:
- Права доступа в формате rwx
- Владелец файла
- Размер в байтах
- Дата и время модификации
- Индикаторы типов файлов (`*` для исполняемых, `/` для директорий)

## Задание 4: Подсчет файлов по расширению

Создан скрипт `file_counter.sh`, который подсчитывает количество файлов с заданным расширением в указанной директории.

**Содержимое скрипта:**

```bash
#!/bin/bash
# Script to count files by extension in a specified directory

# Check if correct number of arguments provided
if [ $# -ne 2 ]; then
    echo "Usage: $0 <file_extension> <directory_path>"
    echo "Example: $0 .txt /home/user/documents"
    exit 1
fi

# Get arguments
EXTENSION=$1
DIRECTORY=$2

# Check if directory exists
if [ ! -d "$DIRECTORY" ]; then
    echo "Error: Directory $DIRECTORY does not exist"
    exit 1
fi

# Count files with the specified extension
# Using find to locate files, then counting them
COUNT=$(find "$DIRECTORY" -type f -name "*$EXTENSION" | wc -l)

echo "Number of files with extension $EXTENSION in $DIRECTORY: $COUNT"

# Optionally, list the files found
echo ""
echo "Files found:"
find "$DIRECTORY" -type f -name "*$EXTENSION"
```

**Описание работы скрипта:**

1. Проверяется количество аргументов (должно быть ровно 2)
2. Если аргументов недостаточно, выводится сообщение об использовании
3. Сохраняются аргументы в переменные `EXTENSION` и `DIRECTORY`
4. Проверяется существование указанной директории
5. Используется команда `find` для поиска файлов:
   - `-type f` — только обычные файлы (не директории)
   - `-name "*$EXTENSION"` — имя заканчивается на указанное расширение
   - Результат передается в `wc -l` для подсчета строк
6. Выводится количество найденных файлов
7. Дополнительно выводится список всех найденных файлов

Запуск скрипта показан на рисунке @fig-run2.

![Запуск скрипта file_counter.sh](image/run2.png){#fig-run2 width=80%}

**Пример выполнения скрипта:**

```bash
$ ./file_counter.sh .sh .
Number of files with extension .sh in .: 4

Files found:
./backup_script.sh
./ls_like.sh
./argument_handler.sh
./file_counter.sh
```

Скрипт находит все файлы с расширением `.sh` в текущей директории и выводит их количество (4 файла) и полный список найденных файлов.

# Выводы

В ходе выполнения лабораторной работы были получены практические навыки программирования в командной оболочке bash:

1. ✅ **Работа с файловой системой**
   - Создание директорий (`mkdir -p`)
   - Проверка существования файлов и директорий (`-e`, `-f`, `-d`)
   - Получение информации о файлах (`stat`, `basename`)

2. ✅ **Архивация файлов**
   - Использование архиватора `zip`
   - Создание архивов с опциями
   - Работа с временными метками (`date`)

3. ✅ **Обработка аргументов командной строки**
   - Использование специальных переменных (`$#`, `$@`, `$1`, `$2`)
   - Итерация по всем аргументам с помощью циклов
   - Доступ к аргументам по индексу с помощью `eval`

4. ✅ **Циклы и условные операторы**
   - Цикл `for` для перебора элементов
   - Цикл `while` с условием
   - Условный оператор `if` для проверок
   - Инкремент счетчиков (`((counter++))`)

5. ✅ **Работа с командами**
   - Команда `find` для поиска файлов
   - Команда `stat` для получения метаданных
   - Команда `wc` для подсчета строк
   - Перенаправление ошибок (`2>/dev/null`)

6. ✅ **Форматирование вывода**
   - Использование `printf` для форматированного вывода
   - Выравнивание колонок
   - Добавление индикаторов типов файлов

**Полученные навыки:**

Освоенные техники программирования в bash позволяют:

- Автоматизировать рутинные задачи администрирования
- Создавать скрипты для резервного копирования
- Обрабатывать большое количество файлов
- Создавать утилиты для работы с файловой системой
- Писать переносимые скрипты для различных UNIX-систем

Все четыре скрипта успешно выполняют поставленные задачи и демонстрируют различные аспекты программирования в командной оболочке bash.

# Список литературы{.unnumbered}

- Advanced Bash-Scripting Guide: [https://tldp.org/LDP/abs/html/](https://tldp.org/LDP/abs/html/)
- Bash Reference Manual: [https://www.gnu.org/software/bash/manual/](https://www.gnu.org/software/bash/manual/)
- Linux Command Line and Shell Scripting Bible
- UNIX Shell Programming


---
## Author
author:
  name: Mohamed Musa
  student_number: "1032248286"
  group: "НКАбд-05-24"
  year: "2 год"
  email: "1032248286@pfur.ru"
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 19

## Title
title: "Лабораторная работа №12"
subtitle: "Выполнение и отладка программ"
license: "CC BY"
---

# Цель работы

Изучить процесс выполнения и отладки программ в операционной системе Linux, освоить инструменты для мониторинга и управления запущенными процессами.

# Задание

1. Освоить запуск программ и скриптов
2. Научиться отслеживать выполнение процессов
3. Изучить инструменты отладки программ
4. Практиковать управление фоновыми задачами
5. Освоить перенаправление ввода-вывода

# Теоретическое введение

## Процессы в Linux

**Процесс** — это запущенный экземпляр программы, выполняющийся в операционной системе.

**Основные характеристики процесса:**

- **PID (Process ID)** — уникальный идентификатор процесса
- **PPID (Parent Process ID)** — идентификатор родительского процесса
- **UID (User ID)** — идентификатор пользователя, запустившего процесс
- **Состояние** — running, sleeping, stopped, zombie
- **Приоритет** — значение nice от -20 (высший) до 19 (низший)
- **Память** — объем используемой оперативной памяти
- **CPU** — процент использования процессора

**Типы процессов:**

- **Интерактивные** — запущенные из терминала, требуют взаимодействия
- **Фоновые (background)** — выполняются в фоне, не блокируют терминал
- **Демоны (daemons)** — системные процессы, работающие постоянно

## Запуск программ

### Обычный запуск

**Синтаксис:**

```bash
./program          # запуск исполняемого файла
bash script.sh     # запуск bash скрипта
python3 script.py  # запуск Python скрипта
```

**Процесс выполняется на переднем плане:**

- Терминал блокируется до завершения программы
- Можно прервать с помощью `Ctrl+C`
- Можно приостановить с помощью `Ctrl+Z`

### Фоновое выполнение

**Запуск в фоне с помощью `&`:**

```bash
./program &        # запуск в фоне
```

**Особенности:**

- Терминал остается свободным
- Программа продолжает выполняться
- Вывод все еще идет в терминал (если не перенаправлен)
- Возвращается номер задачи и PID

**Пример вывода:**

```
[1] 12345
```

- `[1]` — номер задачи (job number)
- `12345` — PID процесса

### Управление задачами

**Команда `jobs`** — просмотр фоновых задач:

```bash
jobs               # список всех задач
jobs -l            # с PID
jobs -r            # только запущенные
jobs -s            # только остановленные
```

**Вывод команды jobs:**

```
[1]+  Running     ./program &
[2]-  Stopped     vim file.txt
```

- `[1]`, `[2]` — номера задач
- `+` — текущая задача
- `-` — предыдущая задача
- `Running`, `Stopped` — состояние

**Команда `fg`** — перевод задачи на передний план:

```bash
fg                 # перевести текущую задачу
fg %1              # перевести задачу номер 1
fg %program        # перевести задачу по имени
```

**Команда `bg`** — продолжить выполнение в фоне:

```bash
bg                 # продолжить текущую задачу в фоне
bg %1              # продолжить задачу номер 1
```

**Типичный сценарий:**

1. Запустить программу: `./program`
2. Приостановить: `Ctrl+Z`
3. Продолжить в фоне: `bg`
4. Вернуть на передний план: `fg`

### Команда nohup

**nohup** — запуск программы, игнорирующей сигнал HUP (hangup):

```bash
nohup ./program &
```

**Особенности:**

- Программа продолжит работу после закрытия терминала
- Вывод перенаправляется в файл `nohup.out`
- Полезно для долгих задач

**Пример:**

```bash
nohup python3 long_task.py > output.log 2>&1 &
```

## Перенаправление ввода-вывода

### Стандартные потоки

**В Linux каждый процесс имеет три стандартных потока:**

- **stdin (0)** — стандартный ввод (клавиатура)
- **stdout (1)** — стандартный вывод (экран)
- **stderr (2)** — стандартный вывод ошибок (экран)

### Перенаправление вывода

**Перенаправление stdout:**

```bash
command > file.txt          # перезаписать файл
command >> file.txt         # добавить в конец файла
```

**Перенаправление stderr:**

```bash
command 2> errors.txt       # ошибки в файл
command 2>> errors.txt      # добавить ошибки
```

**Перенаправление обоих потоков:**

```bash
command > output.txt 2>&1   # оба потока в один файл
command &> output.txt       # короткая форма (bash)
command > output.txt 2> errors.txt  # в разные файлы
```

**Отбросить вывод:**

```bash
command > /dev/null         # отбросить stdout
command 2> /dev/null        # отбросить stderr
command &> /dev/null        # отбросить все
```

### Перенаправление ввода

**Чтение из файла:**

```bash
command < input.txt         # stdin из файла
```

**Here-document:**

```bash
command << EOF
строка 1
строка 2
EOF
```

**Here-string:**

```bash
command <<< "строка текста"
```

### Конвейеры (Pipes)

**Конвейер `|`** — передача вывода одной команды на вход другой:

```bash
command1 | command2         # stdout command1 → stdin command2
```

**Примеры:**

```bash
# Подсчет строк в выводе
ps aux | wc -l

# Поиск процесса
ps aux | grep firefox

# Сортировка и фильтрация
ls -l | sort -k5 -n | head -10

# Цепочка команд
cat file.txt | grep "error" | sort | uniq -c | sort -rn
```

**Команда `tee`** — вывод и в файл, и на экран:

```bash
command | tee output.txt    # вывод на экран и в файл
command | tee -a output.txt # добавить в файл
```

## Мониторинг процессов

### Команда ps

**ps** — информация о процессах:

```bash
ps                 # процессы текущего терминала
ps -e              # все процессы
ps -ef             # полная информация
ps aux             # BSD стиль, подробная информация
ps -u username     # процессы пользователя
ps -p PID          # информация о конкретном процессе
```

**Полезные комбинации:**

```bash
# Найти процесс по имени
ps aux | grep program_name

# Процессы, использующие больше всего CPU
ps aux --sort=-%cpu | head -10

# Процессы, использующие больше всего памяти
ps aux --sort=-%mem | head -10
```

### Команда top

**top** — интерактивный мониторинг процессов в реальном времени:

```bash
top                # запуск top
```

**Клавиши управления в top:**

- `q` — выход
- `k` — убить процесс (kill)
- `r` — изменить приоритет (renice)
- `M` — сортировка по памяти
- `P` — сортировка по CPU
- `u` — фильтр по пользователю
- `1` — показать все CPU
- `h` — справка

**Опции запуска:**

```bash
top -u username    # процессы пользователя
top -p PID         # конкретный процесс
top -d 5           # обновление каждые 5 секунд
```

### Команда htop

**htop** — улучшенная версия top с цветным интерфейсом:

```bash
htop               # запуск htop
```

**Преимущества htop:**

- Цветной интерфейс
- Использование мыши
- Горизонтальная и вертикальная прокрутка
- Древовидное отображение процессов
- Легкое управление процессами

**Клавиши в htop:**

- `F1` — справка
- `F2` — настройки
- `F3` — поиск
- `F4` — фильтр
- `F5` — древовидный вид
- `F6` — сортировка
- `F9` — убить процесс
- `F10` — выход

### Команда pgrep

**pgrep** — поиск процессов по имени:

```bash
pgrep firefox      # PID процессов firefox
pgrep -u username  # процессы пользователя
pgrep -l firefox   # с именами процессов
```

### Команда pidof

**pidof** — найти PID по имени программы:

```bash
pidof firefox      # PID всех процессов firefox
```

## Управление процессами

### Команда kill

**kill** — отправка сигналов процессам:

```bash
kill PID           # отправить SIGTERM (15)
kill -9 PID        # отправить SIGKILL (9) - принудительное завершение
kill -15 PID       # отправить SIGTERM (15) - корректное завершение
kill -STOP PID     # приостановить процесс
kill -CONT PID     # продолжить процесс
```

**Основные сигналы:**

- **SIGTERM (15)** — корректное завершение (по умолчанию)
- **SIGKILL (9)** — немедленное завершение (нельзя перехватить)
- **SIGHUP (1)** — перезагрузка конфигурации
- **SIGINT (2)** — прерывание (Ctrl+C)
- **SIGSTOP (19)** — приостановка (нельзя перехватить)
- **SIGCONT (18)** — продолжение выполнения

### Команда killall

**killall** — завершение процессов по имени:

```bash
killall firefox    # завершить все процессы firefox
killall -9 program # принудительно завершить
killall -u username # завершить все процессы пользователя
```

### Команда pkill

**pkill** — завершение процессов по шаблону:

```bash
pkill firefox      # завершить процессы firefox
pkill -u username  # завершить процессы пользователя
pkill -9 pattern   # принудительно завершить
```

### Команда nice и renice

**nice** — запуск программы с заданным приоритетом:

```bash
nice -n 10 ./program    # запустить с приоритетом 10
nice -n -5 ./program    # запустить с приоритетом -5 (требует root)
```

**renice** — изменение приоритета запущенного процесса:

```bash
renice -n 5 -p PID      # установить приоритет 5
renice -n 10 -u username # для всех процессов пользователя
```

**Значения nice:**

- `-20` — наивысший приоритет (только root)
- `0` — нормальный приоритет (по умолчанию)
- `19` — низший приоритет

## Отладка программ

### Отладка bash скриптов

**Опция `-x`** — вывод выполняемых команд:

```bash
bash -x script.sh          # запуск с трассировкой
```

**Опция `-v`** — вывод строк скрипта:

```bash
bash -v script.sh          # вывод строк перед выполнением
```

**Опция `-n`** — проверка синтаксиса без выполнения:

```bash
bash -n script.sh          # проверка синтаксиса
```

**Использование set в скрипте:**

```bash
#!/bin/bash

set -x    # включить трассировку
# код для отладки
set +x    # выключить трассировку

set -e    # прервать при ошибке
set -u    # ошибка при использовании неопределенных переменных
set -o pipefail  # ошибка в конвейере
```

**Вывод отладочной информации:**

```bash
#!/bin/bash

DEBUG=1

debug() {
    if [ "$DEBUG" = "1" ]; then
        echo "DEBUG: $*" >&2
    fi
}

debug "Начало выполнения"
# основной код
debug "Завершение выполнения"
```

### Отладка с помощью GDB

**GDB (GNU Debugger)** — мощный отладчик для C/C++ программ.

**Компиляция с отладочной информацией:**

```bash
gcc -g program.c -o program    # компиляция с флагом -g
```

**Запуск GDB:**

```bash
gdb ./program                  # запуск отладчика
gdb --args ./program arg1 arg2 # с аргументами
```

**Основные команды GDB:**

```gdb
run                # запустить программу
run arg1 arg2      # запустить с аргументами

break main         # точка останова в функции main
break file.c:10    # точка останова на строке 10
break function     # точка останова в функции

info breakpoints   # список точек останова
delete 1           # удалить точку останова 1
clear function     # удалить точку останова в функции

next               # выполнить следующую строку (не входя в функции)
step               # выполнить следующую строку (входя в функции)
continue           # продолжить выполнение
finish             # выполнить до конца функции

print variable     # вывести значение переменной
print *pointer     # вывести значение по указателю
display variable   # автоматически выводить при каждой остановке

backtrace          # стек вызовов
frame 2            # переключиться на фрейм 2
up                 # вверх по стеку
down               # вниз по стеку

list               # показать исходный код
list function      # показать код функции

watch variable     # остановка при изменении переменной
info locals        # локальные переменные
info args          # аргументы функции

quit               # выйти из GDB
```

**Пример сессии GDB:**

```bash
$ gdb ./program
(gdb) break main
Breakpoint 1 at 0x400526: file program.c, line 5.
(gdb) run
Starting program: /path/to/program

Breakpoint 1, main () at program.c:5
5           int x = 10;
(gdb) next
6           int y = 20;
(gdb) print x
$1 = 10
(gdb) continue
Continuing.
[Inferior 1 (process 12345) exited normally]
(gdb) quit
```

### Отладка с помощью strace

**strace** — трассировка системных вызовов:

```bash
strace ./program               # трассировка всех системных вызовов
strace -o output.txt ./program # вывод в файл
strace -c ./program            # статистика вызовов
strace -e open ./program       # только вызовы open
strace -e trace=file ./program # только файловые операции
strace -p PID                  # подключиться к запущенному процессу
```

**Полезные опции:**

- `-f` — трассировка дочерних процессов
- `-t` — время каждого вызова
- `-T` — длительность каждого вызова
- `-s 1000` — длина строк (по умолчанию 32)

### Отладка с помощью ltrace

**ltrace** — трассировка вызовов библиотечных функций:

```bash
ltrace ./program               # трассировка библиотечных вызовов
ltrace -c ./program            # статистика вызовов
ltrace -o output.txt ./program # вывод в файл
```

### Профилирование программ

**time** — измерение времени выполнения:

```bash
time ./program                 # время выполнения
```

**Вывод:**

```
real    0m1.234s    # реальное время
user    0m0.890s    # время CPU в пользовательском режиме
sys     0m0.123s    # время CPU в режиме ядра
```

**gprof** — профилирование производительности:

```bash
# Компиляция с профилированием
gcc -pg program.c -o program

# Запуск программы (создается gmon.out)
./program

# Анализ результатов
gprof ./program gmon.out > analysis.txt
```

**valgrind** — поиск утечек памяти и ошибок:

```bash
valgrind ./program             # проверка памяти
valgrind --leak-check=full ./program  # полная проверка утечек
valgrind --tool=callgrind ./program   # профилирование
```

# Выполнение лабораторной работы

## Создание тестовых программ

Были созданы тестовые программы для практики выполнения и отладки.

**Простой bash скрипт:**

```bash
#!/bin/bash
# test_script.sh

echo "Начало выполнения скрипта"
echo "Текущая директория: $(pwd)"
echo "Пользователь: $USER"

for i in {1..5}; do
    echo "Итерация $i"
    sleep 1
done

echo "Завершение скрипта"
```

**Программа на C:**

```c
// test_program.c
#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    printf("Программа запущена\n");
    printf("Количество аргументов: %d\n", argc);

    for (int i = 0; i < argc; i++) {
        printf("Аргумент %d: %s\n", i, argv[i]);
    }

    printf("Ожидание 5 секунд...\n");
    sleep(5);

    printf("Программа завершена\n");
    return 0;
}
```

Содержимое первого файла показано на рисунке @fig-content1.

![Содержимое тестового скрипта](image/content1.png){#fig-content1 width=80%}

Содержимое второго файла показано на рисунке @fig-content2.

![Содержимое программы на C](image/content2.png){#fig-content2 width=80%}

## Компиляция программы

Программа на C была скомпилирована:

```bash
# Обычная компиляция
gcc test_program.c -o test_program

# Компиляция с отладочной информацией
gcc -g test_program.c -o test_program_debug

# Компиляция с предупреждениями
gcc -Wall -g test_program.c -o test_program
```

## Запуск программ

### Обычный запуск

Были выполнены различные варианты запуска:

```bash
# Запуск bash скрипта
bash test_script.sh

# Запуск с правами выполнения
chmod +x test_script.sh
./test_script.sh

# Запуск программы на C
./test_program

# Запуск с аргументами
./test_program arg1 arg2 arg3
```

Первый запуск программ показан на рисунке @fig-run1.

![Запуск программ на переднем плане](image/run1.png){#fig-run1 width=80%}

### Фоновое выполнение

Были практикованы фоновые задачи:

```bash
# Запуск в фоне
./test_script.sh &

# Просмотр задач
jobs
jobs -l

# Запуск нескольких задач
./test_program arg1 &
./test_program arg2 &
./test_program arg3 &

# Просмотр всех задач
jobs
```

Второй запуск с фоновыми задачами показан на рисунке @fig-run2.

![Запуск программ в фоновом режиме](image/run2.png){#fig-run2 width=80%}

## Управление задачами

Было практиковано управление фоновыми задачами:

```bash
# Запуск программы
./test_program

# Приостановка (Ctrl+Z)
^Z
[1]+  Stopped     ./test_program

# Продолжение в фоне
bg %1
[1]+ ./test_program &

# Просмотр задач
jobs
[1]+  Running     ./test_program &

# Перевод на передний план
fg %1
```

## Перенаправление ввода-вывода

Были практикованы различные варианты перенаправления:

```bash
# Перенаправление вывода
./test_program > output.txt

# Перенаправление ошибок
./test_program 2> errors.txt

# Перенаправление обоих потоков
./test_program > output.txt 2>&1

# Добавление в файл
./test_program >> output.txt

# Отбрасывание вывода
./test_program > /dev/null 2>&1
```

## Использование конвейеров

Были созданы цепочки команд:

```bash
# Поиск процессов
ps aux | grep test_program

# Подсчет процессов
ps aux | grep test_program | wc -l

# Сортировка по использованию памяти
ps aux | sort -k4 -rn | head -10

# Фильтрация и форматирование
ps aux | grep firefox | awk '{print $2, $11}'

# Сложная цепочка
cat /var/log/syslog | grep error | sort | uniq -c | sort -rn | head -20
```

## Мониторинг процессов

Были использованы инструменты мониторинга:

```bash
# Просмотр всех процессов
ps aux

# Процессы текущего пользователя
ps -u $USER

# Поиск конкретного процесса
pgrep test_program
pidof test_program

# Интерактивный мониторинг
top
htop

# Информация о конкретном процессе
ps -p $(pgrep test_program) -o pid,ppid,cmd,%cpu,%mem
```

## Отладка bash скрипта

Был отлажен bash скрипт:

```bash
# Проверка синтаксиса
bash -n test_script.sh

# Запуск с трассировкой
bash -x test_script.sh

# Запуск с выводом строк
bash -v test_script.sh

# Комбинация опций
bash -xv test_script.sh
```

**Вывод с трассировкой:**

```
+ echo 'Начало выполнения скрипта'
Начало выполнения скрипта
++ pwd
+ echo 'Текущая директория: /home/user'
Текущая директория: /home/user
+ echo 'Пользователь: user'
Пользователь: user
```

## Отладка программы на C

Была выполнена отладка с помощью GDB:

```bash
# Запуск GDB
gdb ./test_program_debug

# Установка точки останова
(gdb) break main
Breakpoint 1 at 0x400526

# Запуск программы
(gdb) run arg1 arg2

# Пошаговое выполнение
(gdb) next
(gdb) next

# Вывод переменных
(gdb) print argc
$1 = 3
(gdb) print argv[1]
$2 = "arg1"

# Продолжение выполнения
(gdb) continue

# Выход
(gdb) quit
```

## Трассировка системных вызовов

Была выполнена трассировка с помощью strace:

```bash
# Трассировка всех вызовов
strace ./test_program

# Вывод в файл
strace -o trace.txt ./test_program

# Статистика вызовов
strace -c ./test_program

# Только файловые операции
strace -e trace=file ./test_program

# Только сетевые операции
strace -e trace=network ./test_program
```

## Управление приоритетами

Было практиковано изменение приоритетов:

```bash
# Запуск с низким приоритетом
nice -n 10 ./test_program

# Запуск с высоким приоритетом (требует root)
sudo nice -n -10 ./test_program

# Изменение приоритета запущенного процесса
PID=$(pgrep test_program)
renice -n 5 -p $PID

# Проверка приоритета
ps -o pid,ni,cmd -p $PID
```

## Завершение процессов

Были практикованы различные способы завершения:

```bash
# Корректное завершение
kill $(pgrep test_program)

# Принудительное завершение
kill -9 $(pgrep test_program)

# Завершение по имени
killall test_program

# Завершение с шаблоном
pkill test_

# Завершение всех процессов пользователя (осторожно!)
# pkill -u username
```

# Выводы

В ходе лабораторной работы были успешно выполнены следующие задачи:

1. ✅ **Освоен запуск программ и скриптов**
   - Изучен обычный запуск программ на переднем плане
   - Практиковано фоновое выполнение с помощью `&`
   - Освоен запуск с помощью `nohup` для долгих задач
   - Изучена компиляция программ на C с различными опциями

2. ✅ **Изучено отслеживание выполнения процессов**
   - Освоена команда `ps` для просмотра процессов
   - Практикован интерактивный мониторинг с помощью `top` и `htop`
   - Изучены команды `pgrep` и `pidof` для поиска процессов
   - Освоен просмотр детальной информации о процессах

3. ✅ **Практикованы инструменты отладки программ**
   - Освоена отладка bash скриптов с опциями `-x`, `-v`, `-n`
   - Изучен отладчик GDB для программ на C/C++
   - Практикована трассировка системных вызовов с помощью `strace`
   - Освоена трассировка библиотечных функций с помощью `ltrace`

4. ✅ **Освоено управление фоновыми задачами**
   - Изучена команда `jobs` для просмотра задач
   - Практикованы команды `fg` и `bg` для управления задачами
   - Освоено приостановление задач с помощью `Ctrl+Z`
   - Изучено завершение процессов с помощью `kill`, `killall`, `pkill`

5. ✅ **Изучено перенаправление ввода-вывода**
   - Освоено перенаправление stdout и stderr в файлы
   - Практикованы конвейеры (pipes) для связывания команд
   - Изучено использование `/dev/null` для отбрасывания вывода
   - Освоена команда `tee` для дублирования вывода

**Дополнительные навыки:**

- ✅ Управление приоритетами процессов с помощью `nice` и `renice`
- ✅ Профилирование программ с помощью `time`, `gprof`, `valgrind`
- ✅ Использование точек останова и пошаговое выполнение в GDB
- ✅ Анализ стека вызовов и переменных в отладчике
- ✅ Создание сложных конвейеров команд для обработки данных
- ✅ Мониторинг использования CPU и памяти процессами

**Полученные знания:**

Получены глубокие навыки выполнения и отладки программ в операционной системе Linux. Освоены:

- **Управление процессами** — запуск, мониторинг, завершение
- **Фоновое выполнение** — работа с задачами, не блокирующими терминал
- **Перенаправление потоков** — гибкое управление вводом-выводом
- **Конвейеры** — создание цепочек команд для обработки данных
- **Отладка** — поиск и исправление ошибок в программах и скриптах
- **Мониторинг** — отслеживание производительности и ресурсов

**Практическое применение:**

Навыки работы с процессами и отладки применимы в следующих областях:

- **Системное администрирование** — управление службами и процессами
- **Разработка ПО** — отладка программ и поиск ошибок
- **Автоматизация** — создание скриптов для фоновых задач
- **Мониторинг систем** — отслеживание производительности приложений
- **DevOps** — управление процессами в production окружении
- **Оптимизация** — профилирование и улучшение производительности

Эти навыки являются фундаментальными для эффективной работы в Linux и необходимы любому системному администратору, разработчику или DevOps инженеру.

# Список литературы{.unnumbered}

::: {#refs}
- Linux Process Management: [https://linux.die.net/man/](https://linux.die.net/man/)
- Advanced Bash-Scripting Guide: [https://tldp.org/LDP/abs/html/](https://tldp.org/LDP/abs/html/)
- Bash Debugging: [https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html)
- GDB Documentation: [https://www.gnu.org/software/gdb/documentation/](https://www.gnu.org/software/gdb/documentation/)
- Debugging with GDB: [https://sourceware.org/gdb/current/onlinedocs/gdb/](https://sourceware.org/gdb/current/onlinedocs/gdb/)
- strace Manual: [https://man7.org/linux/man-pages/man1/strace.1.html](https://man7.org/linux/man-pages/man1/strace.1.html)
- htop Manual: [https://htop.dev/](https://htop.dev/)
- Linux Performance: [https://www.brendangregg.com/linuxperf.html](https://www.brendangregg.com/linuxperf.html)
:::

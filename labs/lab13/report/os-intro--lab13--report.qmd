---
## Author
author:
  name: Mohamed Musa
  student_number: "1032248286"
  group: "НКАбд-05-24"
  year: "2 год"
  email: "1032248286@pfur.ru"
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 19

## Title
title: "Лабораторная работа №13"
subtitle: "Работа с shell скриптами"
license: "CC BY"
---

# Цель работы

Изучить основы создания и выполнения shell скриптов в Linux, освоить работу с переменными, условиями и циклами в bash программировании.

# Задание

1. Освоить создание shell скриптов
2. Научиться работать с переменными и параметрами
3. Изучить условные операторы и циклы
4. Практиковать обработку аргументов командной строки
5. Освоить отладку скриптов

# Теоретическое введение

## Что такое Shell скрипты

**Shell скрипт** — это текстовый файл, содержащий последовательность команд для выполнения в командной оболочке (shell). Скрипты позволяют автоматизировать повторяющиеся задачи, создавать сложные программы и упрощать администрирование системы.

**Преимущества shell скриптов:**

- **Автоматизация** — выполнение рутинных задач без участия пользователя
- **Простота** — не требуется компиляция, легко редактировать
- **Интеграция** — прямой доступ ко всем системным командам
- **Портативность** — работают на любой Unix-подобной системе
- **Быстрая разработка** — можно быстро создавать и тестировать

## Структура shell скрипта

**Базовая структура:**

```bash
#!/bin/bash
# Комментарий: описание скрипта

# Переменные
variable="value"

# Команды
echo "Hello, World!"
echo $variable

# Условия
if [ condition ]; then
    # действия
fi

# Циклы
for i in {1..5}; do
    echo $i
done
```

**Основные элементы:**

1. **Shebang** (`#!/bin/bash`) — первая строка, указывает интерпретатор
2. **Комментарии** (`#`) — пояснения к коду
3. **Переменные** — хранение данных
4. **Команды** — выполнение системных команд
5. **Управляющие конструкции** — условия, циклы, функции

## Shebang (Хэшбэнг)

**Shebang** — это специальная последовательность символов `#!` в начале скрипта, указывающая путь к интерпретатору.

**Примеры:**

```bash
#!/bin/bash           # Bash shell
#!/bin/sh             # Bourne shell (POSIX)
#!/usr/bin/env bash   # Bash через env (более портативно)
#!/usr/bin/python3    # Python 3
#!/usr/bin/perl       # Perl
```

**Использование env:**

```bash
#!/usr/bin/env bash
```

Преимущество: `env` ищет интерпретатор в `PATH`, что делает скрипт более портативным.

## Переменные в Bash

### Объявление переменных

**Синтаксис:**

```bash
variable_name="value"    # БЕЗ пробелов вокруг =
```

**Правила именования:**

- Начинается с буквы или подчеркивания
- Может содержать буквы, цифры, подчеркивания
- Регистрозависимые (`VAR` и `var` — разные переменные)
- Не использовать зарезервированные слова

**Примеры:**

```bash
name="John"
age=25
_temp="temporary"
USER_HOME="/home/user"
```

### Использование переменных

**Обращение к переменной:**

```bash
echo $variable          # простое обращение
echo ${variable}        # с фигурными скобками (рекомендуется)
echo "${variable}"      # в кавычках (сохраняет пробелы)
```

**Примеры:**

```bash
name="Alice"
echo "Hello, $name"           # Hello, Alice
echo "Hello, ${name}!"        # Hello, Alice!
echo "Path: ${HOME}/docs"     # Path: /home/user/docs
```

### Специальные переменные

**Параметры скрипта:**

- `$0` — имя скрипта
- `$1`, `$2`, ..., `$9` — позиционные параметры (аргументы)
- `${10}`, `${11}`, ... — параметры с номером > 9
- `$#` — количество аргументов
- `$@` — все аргументы как отдельные слова
- `$*` — все аргументы как одна строка
- `$?` — код возврата последней команды
- `$$` — PID текущего процесса
- `$!` — PID последнего фонового процесса

**Переменные окружения:**

- `$HOME` — домашняя директория пользователя
- `$USER` — имя пользователя
- `$PWD` — текущая директория
- `$OLDPWD` — предыдущая директория
- `$PATH` — пути поиска команд
- `$SHELL` — путь к текущей оболочке
- `$HOSTNAME` — имя хоста

**Примеры использования:**

```bash
#!/bin/bash

echo "Имя скрипта: $0"
echo "Первый аргумент: $1"
echo "Второй аргумент: $2"
echo "Количество аргументов: $#"
echo "Все аргументы: $@"
echo "Пользователь: $USER"
echo "Домашняя директория: $HOME"
```

### Операции с переменными

**Длина строки:**

```bash
string="Hello"
echo ${#string}         # 5
```

**Подстроки:**

```bash
string="Hello World"
echo ${string:0:5}      # Hello (с позиции 0, длина 5)
echo ${string:6}        # World (с позиции 6 до конца)
```

**Замена подстроки:**

```bash
string="Hello World"
echo ${string/World/Bash}    # Hello Bash (первое вхождение)
echo ${string//o/0}          # Hell0 W0rld (все вхождения)
```

**Значение по умолчанию:**

```bash
echo ${variable:-default}    # default если variable пустая
echo ${variable:=default}    # присвоить default если пустая
```

## Условные операторы

### Оператор if

**Синтаксис:**

```bash
if [ condition ]; then
    # команды если истина
elif [ condition2 ]; then
    # команды если condition2 истина
else
    # команды если все ложь
fi
```

**Примеры:**

```bash
if [ $age -gt 18 ]; then
    echo "Совершеннолетний"
else
    echo "Несовершеннолетний"
fi
```

### Операторы сравнения

**Числовые сравнения:**

- `-eq` — равно (equal)
- `-ne` — не равно (not equal)
- `-gt` — больше (greater than)
- `-ge` — больше или равно (greater or equal)
- `-lt` — меньше (less than)
- `-le` — меньше или равно (less or equal)

**Примеры:**

```bash
if [ $num -eq 10 ]; then
    echo "Число равно 10"
fi

if [ $age -ge 18 ]; then
    echo "Взрослый"
fi
```

**Строковые сравнения:**

- `=` или `==` — строки равны
- `!=` — строки не равны
- `<` — меньше (лексикографически)
- `>` — больше (лексикографически)
- `-z` — строка пустая (zero length)
- `-n` — строка не пустая (non-zero length)

**Примеры:**

```bash
if [ "$name" = "Alice" ]; then
    echo "Привет, Алиса!"
fi

if [ -z "$variable" ]; then
    echo "Переменная пустая"
fi

if [ -n "$variable" ]; then
    echo "Переменная не пустая"
fi
```

**Проверка файлов:**

- `-e` — файл существует (exists)
- `-f` — обычный файл (file)
- `-d` — директория (directory)
- `-r` — файл доступен для чтения (readable)
- `-w` — файл доступен для записи (writable)
- `-x` — файл исполняемый (executable)
- `-s` — файл не пустой (size > 0)
- `-L` — символическая ссылка (link)

**Примеры:**

```bash
if [ -f "/etc/passwd" ]; then
    echo "Файл существует"
fi

if [ -d "/home/user" ]; then
    echo "Директория существует"
fi

if [ -x "./script.sh" ]; then
    echo "Скрипт исполняемый"
fi
```

### Логические операторы

**Операторы:**

- `&&` — логическое И (AND)
- `||` — логическое ИЛИ (OR)
- `!` — логическое НЕ (NOT)

**Примеры:**

```bash
# И (AND)
if [ $age -ge 18 ] && [ $age -le 65 ]; then
    echo "Трудоспособный возраст"
fi

# ИЛИ (OR)
if [ "$name" = "Alice" ] || [ "$name" = "Bob" ]; then
    echo "Известное имя"
fi

# НЕ (NOT)
if [ ! -f "/tmp/file.txt" ]; then
    echo "Файл не существует"
fi
```

### Оператор case

**Синтаксис:**

```bash
case $variable in
    pattern1)
        # команды
        ;;
    pattern2)
        # команды
        ;;
    *)
        # команды по умолчанию
        ;;
esac
```

**Примеры:**

```bash
case $choice in
    1)
        echo "Выбрана опция 1"
        ;;
    2)
        echo "Выбрана опция 2"
        ;;
    [3-5])
        echo "Выбрана опция 3, 4 или 5"
        ;;
    *)
        echo "Неизвестная опция"
        ;;
esac
```

## Циклы

### Цикл for

**Синтаксис 1 (диапазон):**

```bash
for variable in list; do
    # команды
done
```

**Примеры:**

```bash
# Перебор чисел
for i in 1 2 3 4 5; do
    echo "Число: $i"
done

# Диапазон
for i in {1..10}; do
    echo $i
done

# С шагом
for i in {0..20..2}; do
    echo $i    # 0, 2, 4, ..., 20
done

# Перебор файлов
for file in *.txt; do
    echo "Обработка: $file"
done

# Перебор аргументов
for arg in "$@"; do
    echo "Аргумент: $arg"
done
```

**Синтаксис 2 (C-style):**

```bash
for ((i=0; i<10; i++)); do
    echo $i
done
```

### Цикл while

**Синтаксис:**

```bash
while [ condition ]; do
    # команды
done
```

**Примеры:**

```bash
# Счетчик
counter=1
while [ $counter -le 5 ]; do
    echo "Итерация: $counter"
    ((counter++))
done

# Чтение файла построчно
while IFS= read -r line; do
    echo "Строка: $line"
done < file.txt

# Бесконечный цикл
while true; do
    echo "Нажмите Ctrl+C для выхода"
    sleep 1
done
```

### Цикл until

**Синтаксис:**

```bash
until [ condition ]; do
    # команды
done
```

**Примеры:**

```bash
counter=1
until [ $counter -gt 5 ]; do
    echo "Счетчик: $counter"
    ((counter++))
done
```

### Управление циклами

**Команды:**

- `break` — выход из цикла
- `continue` — переход к следующей итерации

**Примеры:**

```bash
# break
for i in {1..10}; do
    if [ $i -eq 5 ]; then
        break    # выход при i=5
    fi
    echo $i
done

# continue
for i in {1..10}; do
    if [ $((i % 2)) -eq 0 ]; then
        continue    # пропустить четные
    fi
    echo $i
done
```

## Функции

### Объявление функций

**Синтаксис 1:**

```bash
function_name() {
    # команды
}
```

**Синтаксис 2:**

```bash
function function_name {
    # команды
}
```

**Примеры:**

```bash
# Простая функция
greet() {
    echo "Привет!"
}

# Вызов функции
greet

# Функция с параметрами
greet_user() {
    echo "Привет, $1!"
}

greet_user "Alice"    # Привет, Alice!
```

### Параметры функций

**Доступ к параметрам:**

- `$1`, `$2`, ... — позиционные параметры
- `$#` — количество параметров
- `$@` — все параметры
- `$*` — все параметры как одна строка

**Примеры:**

```bash
sum() {
    local result=$(($1 + $2))
    echo $result
}

result=$(sum 5 3)
echo "Сумма: $result"    # Сумма: 8
```

### Локальные переменные

**Использование local:**

```bash
my_function() {
    local local_var="локальная"
    global_var="глобальная"
    echo $local_var
}

my_function
echo $global_var    # доступна
echo $local_var     # не доступна (пустая)
```

### Возврат значений

**Команда return:**

```bash
is_even() {
    if [ $(($1 % 2)) -eq 0 ]; then
        return 0    # истина (четное)
    else
        return 1    # ложь (нечетное)
    fi
}

if is_even 4; then
    echo "Четное"
fi
```

**Вывод через echo:**

```bash
multiply() {
    echo $(($1 * $2))
}

result=$(multiply 6 7)
echo "Результат: $result"    # Результат: 42
```

## Работа с аргументами командной строки

### Обработка аргументов

**Примеры:**

```bash
#!/bin/bash

# Проверка количества аргументов
if [ $# -eq 0 ]; then
    echo "Использование: $0 <аргументы>"
    exit 1
fi

# Обработка всех аргументов
for arg in "$@"; do
    echo "Аргумент: $arg"
done

# Доступ к конкретным аргументам
echo "Первый аргумент: $1"
echo "Второй аргумент: $2"
```

### Команда getopts

**Обработка опций:**

```bash
#!/bin/bash

while getopts "a:b:c" opt; do
    case $opt in
        a)
            echo "Опция -a с значением: $OPTARG"
            ;;
        b)
            echo "Опция -b с значением: $OPTARG"
            ;;
        c)
            echo "Опция -c"
            ;;
        \?)
            echo "Неверная опция: -$OPTARG"
            exit 1
            ;;
    esac
done
```

## Отладка скриптов

### Опции отладки

**Команды:**

```bash
bash -x script.sh    # трассировка выполнения
bash -v script.sh    # вывод строк скрипта
bash -n script.sh    # проверка синтаксиса
```

**В скрипте:**

```bash
#!/bin/bash

set -x    # включить трассировку
# код
set +x    # выключить трассировку

set -e    # прервать при ошибке
set -u    # ошибка при использовании неопределенных переменных
set -o pipefail    # ошибка в конвейере
```

### Вывод отладочной информации

**Примеры:**

```bash
# Вывод значений переменных
echo "DEBUG: variable=$variable"

# Проверка условий
if [ condition ]; then
    echo "DEBUG: Условие истинно"
fi

# Трассировка функций
function_name() {
    echo "DEBUG: Вход в функцию с параметрами: $@"
    # код функции
    echo "DEBUG: Выход из функции"
}
```

## Создание и запуск скриптов

### Создание скрипта

**Шаги:**

1. Создать файл: `touch script.sh`
2. Добавить shebang: `#!/bin/bash`
3. Написать код
4. Сделать исполняемым: `chmod +x script.sh`
5. Запустить: `./script.sh`

**Пример:**

```bash
# Создание
cat > hello.sh << 'EOF'
#!/bin/bash
echo "Hello, World!"
EOF

# Права на выполнение
chmod +x hello.sh

# Запуск
./hello.sh
```

### Способы запуска

**Различные способы:**

```bash
./script.sh          # прямой запуск (требует chmod +x)
bash script.sh       # запуск через bash
sh script.sh         # запуск через sh
source script.sh     # выполнение в текущей оболочке
. script.sh          # то же что source
```

# Выполнение лабораторной работы

## Содержимое скриптов

Были изучены содержимое различных скриптов. Первое содержимое показано на рисунке @fig-content1.

![Содержимое скрипта 1](image/content1.png){#fig-content1 width=80%}

Второе содержимое показано на рисунке @fig-content2.

![Содержимое скрипта 2](image/content2.png){#fig-content2 width=80%}

Содержимое shell скрипта показано на рисунке @fig-shcontent1.

![Содержимое shell скрипта](image/shcontent1.png){#fig-shcontent1 width=80%}

## Программный код

Было изучено содержимое программы. Программа показана на рисунке @fig-program1.

![Программный код](image/program1.png){#fig-program1 width=80%}

## Запуск программ

Был произведен запуск различных программ. Результаты показаны на рисунке @fig-run2.

![Запуск программ](image/run2.png){#fig-run2 width=80%}

## Практическая работа

В ходе работы были созданы и выполнены различные скрипты для практики основных концепций shell программирования.

### Скрипт с переменными и условиями

Был создан скрипт для приветствия пользователя в зависимости от времени суток:

```bash
#!/bin/bash
# Скрипт приветствия с учетом времени

# Получение имени из аргумента
name=$1

# Проверка наличия аргумента
if [ -z "$name" ]; then
    echo "Использование: $0 <имя>"
    exit 1
fi

# Получение текущего часа
current_hour=$(date +%H)

# Приветствие
echo "Привет, $name!"

# Приветствие в зависимости от времени
if [ $current_hour -lt 12 ]; then
    echo "Доброе утро!"
elif [ $current_hour -lt 18 ]; then
    echo "Добрый день!"
else
    echo "Добрый вечер!"
fi

# Вывод дополнительной информации
echo "Текущее время: $(date +%H:%M)"
echo "Текущая дата: $(date +%d.%m.%Y)"
```

**Запуск:**

```bash
chmod +x greet.sh
./greet.sh Alice
```

### Скрипт с циклами

Был создан скрипт для обработки файлов с использованием циклов:

```bash
#!/bin/bash
# Скрипт для обработки текстовых файлов

echo "=== Обработка текстовых файлов ==="

# Проверка наличия файлов
if ! ls *.txt &> /dev/null; then
    echo "Текстовые файлы не найдены"
    exit 1
fi

# Счетчик файлов
count=0

# Цикл for для обработки файлов
for file in *.txt; do
    ((count++))
    echo ""
    echo "[$count] Файл: $file"
    echo "    Размер: $(du -h "$file" | cut -f1)"
    echo "    Строк: $(wc -l < "$file")"
    echo "    Слов: $(wc -w < "$file")"
    echo "    Символов: $(wc -c < "$file")"
done

echo ""
echo "Всего обработано файлов: $count"
```

### Скрипт с функциями

Был создан скрипт с использованием функций для вычислений:

```bash
#!/bin/bash
# Калькулятор с функциями

# Функция сложения
add() {
    echo $(($1 + $2))
}

# Функция вычитания
subtract() {
    echo $(($1 - $2))
}

# Функция умножения
multiply() {
    echo $(($1 * $2))
}

# Функция деления
divide() {
    if [ $2 -eq 0 ]; then
        echo "Ошибка: деление на ноль"
        return 1
    fi
    echo $(($1 / $2))
}

# Главная функция
main() {
    echo "=== Калькулятор ==="

    num1=10
    num2=5

    echo "Числа: $num1 и $num2"
    echo "Сложение: $(add $num1 $num2)"
    echo "Вычитание: $(subtract $num1 $num2)"
    echo "Умножение: $(multiply $num1 $num2)"
    echo "Деление: $(divide $num1 $num2)"
}

# Запуск главной функции
main
```

### Скрипт с обработкой аргументов

Был создан скрипт для обработки опций командной строки:

```bash
#!/bin/bash
# Скрипт с обработкой опций

# Значения по умолчанию
verbose=false
output_file=""
input_file=""

# Функция помощи
show_help() {
    echo "Использование: $0 [опции]"
    echo "Опции:"
    echo "  -v          Подробный вывод"
    echo "  -i <файл>   Входной файл"
    echo "  -o <файл>   Выходной файл"
    echo "  -h          Показать эту справку"
}

# Обработка опций
while getopts "vi:o:h" opt; do
    case $opt in
        v)
            verbose=true
            ;;
        i)
            input_file="$OPTARG"
            ;;
        o)
            output_file="$OPTARG"
            ;;
        h)
            show_help
            exit 0
            ;;
        \?)
            echo "Неверная опция: -$OPTARG"
            show_help
            exit 1
            ;;
    esac
done

# Вывод информации
if [ "$verbose" = true ]; then
    echo "Подробный режим включен"
    echo "Входной файл: ${input_file:-не указан}"
    echo "Выходной файл: ${output_file:-не указан}"
fi

# Обработка файлов
if [ -n "$input_file" ]; then
    if [ -f "$input_file" ]; then
        echo "Обработка файла: $input_file"
        # Обработка...
    else
        echo "Ошибка: файл $input_file не найден"
        exit 1
    fi
fi
```

### Скрипт с циклом while

Был создан скрипт для чтения файла построчно:

```bash
#!/bin/bash
# Чтение файла построчно

file="data.txt"

# Проверка существования файла
if [ ! -f "$file" ]; then
    echo "Файл $file не найден"
    exit 1
fi

echo "=== Чтение файла $file ==="

# Счетчик строк
line_number=0

# Чтение построчно
while IFS= read -r line; do
    ((line_number++))
    echo "[$line_number] $line"
done < "$file"

echo ""
echo "Всего строк: $line_number"
```

### Скрипт с оператором case

Был создан интерактивный скрипт меню:

```bash
#!/bin/bash
# Интерактивное меню

while true; do
    echo ""
    echo "=== Главное меню ==="
    echo "1. Показать дату и время"
    echo "2. Показать текущую директорию"
    echo "3. Показать пользователей"
    echo "4. Показать использование диска"
    echo "5. Выход"
    echo ""
    read -p "Выберите опцию [1-5]: " choice

    case $choice in
        1)
            echo "Дата и время: $(date)"
            ;;
        2)
            echo "Текущая директория: $(pwd)"
            ;;
        3)
            echo "Пользователи в системе:"
            who
            ;;
        4)
            echo "Использование диска:"
            df -h
            ;;
        5)
            echo "Выход..."
            exit 0
            ;;
        *)
            echo "Неверный выбор. Попробуйте снова."
            ;;
    esac

    read -p "Нажмите Enter для продолжения..."
done
```

## Отладка скриптов

Были изучены и применены различные методы отладки скриптов.

### Трассировка выполнения

**Запуск с опцией -x:**

```bash
# Трассировка всех команд
bash -x script.sh

# Пример вывода:
# + name=Alice
# + current_hour=14
# + echo 'Привет, Alice!'
# Привет, Alice!
# + '[' 14 -lt 12 ']'
# + '[' 14 -lt 18 ']'
# + echo 'Добрый день!'
# Добрый день!
```

### Проверка синтаксиса

**Запуск с опцией -n:**

```bash
# Проверка без выполнения
bash -n script.sh

# Если есть ошибки:
# script.sh: line 10: syntax error near unexpected token `fi'
# script.sh: line 10: `fi'
```

### Вывод строк скрипта

**Запуск с опцией -v:**

```bash
# Вывод строк перед выполнением
bash -v script.sh
```

### Отладка внутри скрипта

**Использование set:**

```bash
#!/bin/bash

# Включить трассировку
set -x

# Код с трассировкой
echo "Отладка включена"
variable="test"

# Выключить трассировку
set +x

# Код без трассировки
echo "Отладка выключена"

# Прервать при ошибке
set -e

# Ошибка при неопределенных переменных
set -u

# Ошибка в конвейере
set -o pipefail
```

### Добавление отладочных сообщений

**Примеры:**

```bash
#!/bin/bash

DEBUG=true

debug_print() {
    if [ "$DEBUG" = true ]; then
        echo "DEBUG: $@" >&2
    fi
}

# Использование
debug_print "Начало скрипта"
variable="value"
debug_print "Переменная установлена: $variable"

# Проверка условий
if [ condition ]; then
    debug_print "Условие истинно"
fi
```

# Выводы

В ходе лабораторной работы были успешно выполнены следующие задачи:

## Выполненные задачи

1. **✅ Освоено создание shell скриптов**
   - Изучена структура скриптов с shebang
   - Практиковано создание исполняемых файлов
   - Освоены различные способы запуска скриптов
   - Изучены правила именования и организации кода

2. **✅ Изучена работа с переменными и параметрами**
   - Освоено объявление и использование переменных
   - Изучены специальные переменные ($0, $1, $#, $@, $?, $$)
   - Практикованы переменные окружения ($HOME, $USER, $PWD)
   - Освоены операции с переменными (длина, подстроки, замена)
   - Изучены значения по умолчанию

3. **✅ Практикованы условные операторы и циклы**
   - Освоен оператор if-elif-else
   - Изучены операторы сравнения (числовые, строковые, файловые)
   - Практикованы логические операторы (&&, ||, !)
   - Освоен оператор case для множественного выбора
   - Изучены циклы for, while, until
   - Практикованы команды break и continue

4. **✅ Освоена обработка аргументов командной строки**
   - Изучен доступ к позиционным параметрам
   - Практикована проверка количества аргументов
   - Освоена команда getopts для обработки опций
   - Созданы скрипты с различными режимами работы
   - Реализована функция помощи (help)

5. **✅ Изучена отладка скриптов**
   - Освоены опции bash (-x, -v, -n)
   - Практикованы команды set для управления отладкой
   - Изучено добавление отладочных сообщений
   - Освоены методы поиска и исправления ошибок
   - Практикована проверка синтаксиса

## Дополнительные навыки

В процессе выполнения работы были освоены дополнительные навыки:

- **Создание функций** — объявление, параметры, локальные переменные, возврат значений
- **Работа с файлами** — чтение построчно, проверка существования, обработка
- **Интерактивные скрипты** — меню, ввод пользователя, циклы взаимодействия
- **Обработка текста** — подсчет строк, слов, символов, форматирование вывода
- **Управление потоками** — перенаправление вывода, обработка ошибок
- **Организация кода** — структурирование, комментирование, читаемость

## Полученные знания

Получены фундаментальные знания в области shell программирования:

- **Основы bash** — синтаксис, структура, выполнение скриптов
- **Переменные** — типы, операции, специальные переменные, окружение
- **Управляющие конструкции** — условия, циклы, ветвление
- **Функции** — создание, параметры, область видимости, возврат значений
- **Обработка данных** — аргументы, файлы, текст, форматирование
- **Отладка** — методы, инструменты, поиск ошибок, оптимизация

## Практическое применение

Полученные навыки могут быть применены в следующих областях:

- **Автоматизация задач** — создание скриптов для рутинных операций
- **Системное администрирование** — управление системой, мониторинг, резервное копирование
- **DevOps** — автоматизация развертывания, CI/CD, управление конфигурациями
- **Обработка данных** — парсинг логов, обработка текстовых файлов, генерация отчетов
- **Разработка инструментов** — создание утилит командной строки, скриптов установки
- **Интеграция систем** — связывание различных программ и сервисов

## Значимость навыков

Навыки shell программирования являются **фундаментальными** для:

- Эффективной работы в Linux и Unix-подобных системах
- Автоматизации повторяющихся задач
- Системного администрирования и DevOps
- Разработки программного обеспечения
- Обработки и анализа данных

Освоение shell скриптов открывает широкие возможности для автоматизации и повышения производительности работы в командной строке.

# Список литературы{.unnumbered}

::: {#refs}
1. Advanced Bash-Scripting Guide — Comprehensive guide to bash scripting: [https://tldp.org/LDP/abs/html/](https://tldp.org/LDP/abs/html/)

2. GNU Bash Manual — Official bash documentation: [https://www.gnu.org/software/bash/manual/](https://www.gnu.org/software/bash/manual/)

3. Shell Script Debugging — Debugging techniques and best practices: [https://www.shellscript.sh/debug.html](https://www.shellscript.sh/debug.html)

4. Bash Guide for Beginners — Introduction to bash programming: [https://tldp.org/LDP/Bash-Beginners-Guide/html/](https://tldp.org/LDP/Bash-Beginners-Guide/html/)

5. ShellCheck — Shell script analysis tool: [https://www.shellcheck.net/](https://www.shellcheck.net/)

6. Linux Command Line and Shell Scripting Bible — Comprehensive resource: [https://www.wiley.com/](https://www.wiley.com/)

7. Bash Hackers Wiki — Community-driven bash documentation: [https://wiki.bash-hackers.org/](https://wiki.bash-hackers.org/)

8. Google Shell Style Guide — Best practices for shell scripts: [https://google.github.io/styleguide/shellguide.html](https://google.github.io/styleguide/shellguide.html)
:::
